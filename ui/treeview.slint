// largely copy-and-paste job from core Slint ('internal/compiler/widgets/common/listview.slint'); looking forward
// to when Slint has a native TreeView control so we don't have to do this

import { Palette, ListView, ScrollView } from "std-widgets.slint";

export struct TreeNode {
    text: string,
    indentation: int,
    has-children: bool,
    is-selected: bool,
    is-open: bool}

component MyFocusBorder inherits Rectangle {
    border-width: 2px;
    Rectangle {
        x: parent.border-width;
        y: parent.border-width;
        width: parent.width - 2 * parent.border-width;
        height: parent.height - 2 * parent.border-width;
        border-width: 1px;
        border-radius: parent.border-radius - 2px;
    }
}

component TreeNodeListItem {
    in property <TreeNode> item;
    in property <bool> has-focus;
    in property <int> index;
    callback expand-toggled;
    callback text-clicked;
    min-width: i-layout.min-width;
    min-height: max(40px, i-layout.min-height);
    vertical-stretch: 0;
    horizontal-stretch: 1;
    states [
        is-selected when root.item.is-selected: {
            i-background.background: Palette.selection-background;
            i-selector.height: 16px;
        }
    ]
    if (root.has-focus): MyFocusBorder {
        border-radius: 4px;
    }
    i-background := Rectangle {
        width: root.width - 6px;
        height: root.height - 4px;
        background: transparent;
        border-radius: 4px;
        animate background { duration: 150ms; }
        i-layout := HorizontalLayout {
            padding-left: 16px;
            padding-right: 16px;
            spacing: 4px;
            Rectangle {
                width: root.item.indentation * 20px;
            }

            Text {
                text: !root.item.has-children ? "" : root.item.is-open ? "⊟" : "⊞";
                vertical-alignment: center;
                horizontal-alignment: center;
                width: 20px;
                TouchArea {
                    clicked => {
                        expand-toggled();
                    }
                }
            }

            i-text := Text {
                text: root.item.text;
                vertical-alignment: center;
                horizontal-alignment: left;
                overflow: elide;
                TouchArea {
                    clicked => {
                        text-clicked();
                    }
                }
            }
        }

        i-selector := Rectangle {
            x: 0px;
            y: (parent.height - self.height) / 2;
            width: 3px;
            height: 0px;
            border-radius: 2px;
            animate height {
                duration: 150ms;
                easing: ease-out;
            }
        }
    }

    @children
}

export component TreeViewBase inherits ListView {
    in-out property <[TreeNode]> nodes;
    callback current-item-changed(/* current-item */ int);
    callback item-pointer-event(/* item-index */ int, /* event */ PointerEvent, /* absolute mouse position */ Point);
    public function set-current-item(index: int) {
        if (index < 0 || index >= nodes.length) {
            return;
        }
        bring-into-view(index);
        root.nodes[index].is-selected = true;
        focus-item = index;
        current-item-changed(index);
    }
    private property <length> item-height: self.viewport-height / self.nodes.length;
    private property <int> into-view-item: 0;
    private property <length> into-view-item-y: root.item-y(root.into-view-item);
    private property <length> current-item-y: root.item-y(root.focus-item);
    private property <int> focus-item: 0;
    pure function first-visible-item() -> int {
        return min(root.nodes.length - 1, max(0, round(-root.viewport-y / root.item-height)));
    }
    pure function item-y(index: int) -> length {
        return root.viewport-y + index * root.item-height;
    }
    public function bring-into-view(row: int) {
        if (row < 0 || row >= nodes.length) {
            return;
        }
        into-view-item = row;
        if (into-view-item-y < 0) {
            root.visible = false;
            self.viewport-y += 0 - into-view-item-y;
        }
        if (into-view-item-y + item-height > self.visible-height) {
            root.visible = false;
            self.viewport-y -= into-view-item-y + item-height - self.visible-height;
        }
    }
    protected function focus-up() {
        root.set-focus-item(root.focus-item - 1);
    }
    protected function focus-down() {
        root.set-focus-item(root.focus-item + 1);
    }
    protected function select-focus-item() {
        root.set-current-item(root.focus-item);
    }
    protected function focus-current-item() {
        //root.focus-item = max(0, root.current-item);
        if (root.current-item-y + root.item-height < 0 || root.current-item-y > root.height) {
            root.focus-item = root.first-visible-item();
        }
    }
    protected function set-focus-item(index: int) {
        root.focus-item = min(root.nodes.length - 1, max(0, index));
        root.bring-into-view(root.focus-item);
    }
    for item[index] in root.nodes: TreeNodeListItem {
        height: self.min-height;
        item: item;
        index: index;
        has-focus: root.has-focus && index == root.focus-item;
        expand-toggled => {
            item.is-open = !item.is-open;
        }
        text-clicked => {
            root.set-current-item(index);
        }
    }
}

export component TreeView inherits TreeViewBase {
    forward-focus: i-focus-scope;
    i-focus-scope := FocusScope {
        x: 0;
        width: 0;
        // Do not react on clicks

        focus-changed-event => {
            root.focus-current-item();
            root.has-focus = self.has-focus;
        }
        key-pressed(event) => {
            if (event.text == Key.UpArrow) {
                root.focus-up();
                return accept;
            } else if (event.text == Key.DownArrow) {
                root.focus-down();
                return accept;
            } else if (event.text == Key.Return) {
                root.select-focus-item();
                return accept;
            }
            reject
        }
    }
}
